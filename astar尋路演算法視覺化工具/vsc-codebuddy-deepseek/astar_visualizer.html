<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f4f4f4;
        }

        h1 {
            margin-bottom: 20px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(25, 20px);
            grid-template-rows: repeat(25, 20px);
            gap: 1px;
            margin-bottom: 20px;
        }

        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>A* Pathfinding Visualizer</h1>
    <div class="grid" id="grid"></div>
    <div class="controls">
        <button id="findPath">開始尋路 (Find Path)</button>
        <button id="reset">重設 (Reset)</button>
    </div>

    <script>
        // 初始化網格
        const grid = document.getElementById('grid');
        const cells = [];

        for (let i = 0; i < 25 * 25; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = i;
            grid.appendChild(cell);
            cells.push(cell);
        }

        // 變數定義
        let startNode = null;
        let endNode = null;
        let walls = new Set();
        let isSettingStart = true;
        let isSettingEnd = false;
        let isDrawingWalls = false;

        // 事件監聽
        grid.addEventListener('mousedown', handleMouseDown);
        grid.addEventListener('mousemove', handleMouseMove);
        grid.addEventListener('mouseup', () => isDrawingWalls = false);

        document.getElementById('findPath').addEventListener('click', findPath);
        document.getElementById('reset').addEventListener('click', resetGrid);

        // 處理滑鼠點擊
        function handleMouseDown(e) {
            if (e.target.className !== 'cell') return;

            const index = parseInt(e.target.dataset.index);

            if (isSettingStart) {
                setStartNode(index);
                isSettingStart = false;
                isSettingEnd = true;
            } else if (isSettingEnd) {
                setEndNode(index);
                isSettingEnd = false;
            } else {
                isDrawingWalls = true;
                toggleWall(index);
            }
        }

        // 處理滑鼠移動
        function handleMouseMove(e) {
            if (!isDrawingWalls || e.target.className !== 'cell') return;

            const index = parseInt(e.target.dataset.index);
            toggleWall(index);
        }

        // 設置起點
        function setStartNode(index) {
            if (startNode !== null) {
                cells[startNode].style.backgroundColor = '#fdfdfd';
            }
            startNode = index;
            cells[index].style.backgroundColor = '#2ecc71';
        }

        // 設置終點
        function setEndNode(index) {
            if (endNode !== null) {
                cells[endNode].style.backgroundColor = '#fdfdfd';
            }
            endNode = index;
            cells[index].style.backgroundColor = '#e74c3c';
        }

        // 切換障礙物
        function toggleWall(index) {
            if (index === startNode || index === endNode) return;

            if (walls.has(index)) {
                walls.delete(index);
                cells[index].style.backgroundColor = '#fdfdfd';
            } else {
                walls.add(index);
                cells[index].style.backgroundColor = '#34495e';
            }
        }

        // 重置網格
        function resetGrid() {
            startNode = null;
            endNode = null;
            walls = new Set();
            isSettingStart = true;
            isSettingEnd = false;
            isDrawingWalls = false;

            cells.forEach(cell => {
                cell.style.backgroundColor = '#fdfdfd';
            });
        }

        // A* 演算法
        function findPath() {
            if (startNode === null || endNode === null) {
                alert('請先設置起點和終點！');
                return;
            }

            const findPathButton = document.getElementById('findPath');
            findPathButton.disabled = true;

            // 初始化節點
            const openSet = new Set([startNode]);
            const closedSet = new Set();
            const cameFrom = {};
            const gScore = {};
            const fScore = {};

            // 初始化分數
            cells.forEach((_, index) => {
                gScore[index] = Infinity;
                fScore[index] = Infinity;
            });

            gScore[startNode] = 0;
            fScore[startNode] = heuristic(startNode, endNode);

            // 啟發式函數（曼哈頓距離）
            function heuristic(a, b) {
                const x1 = a % 25;
                const y1 = Math.floor(a / 25);
                const x2 = b % 25;
                const y2 = Math.floor(b / 25);
                return Math.abs(x1 - x2) + Math.abs(y1 - y2);
            }

            // 尋找路徑
            function step() {
                if (openSet.size === 0) {
                    alert('無法找到路徑！');
                    findPathButton.disabled = false;
                    return;
                }

                // 找到 fScore 最小的節點
                let current = null;
                let minFScore = Infinity;
                openSet.forEach(node => {
                    if (fScore[node] < minFScore) {
                        minFScore = fScore[node];
                        current = node;
                    }
                });

                // 如果到達終點
                if (current === endNode) {
                    reconstructPath(cameFrom, current);
                    findPathButton.disabled = false;
                    return;
                }

                // 移動節點到封閉列表
                openSet.delete(current);
                closedSet.add(current);
                cells[current].style.backgroundColor = '#f5cba7';

                // 檢查鄰居
                const neighbors = getNeighbors(current);
                neighbors.forEach(neighbor => {
                    if (closedSet.has(neighbor) || walls.has(neighbor)) return;

                    const tentativeGScore = gScore[current] + 1;

                    if (!openSet.has(neighbor)) {
                        openSet.add(neighbor);
                        cells[neighbor].style.backgroundColor = '#aed6f1';
                    } else if (tentativeGScore >= gScore[neighbor]) {
                        return;
                    }

                    cameFrom[neighbor] = current;
                    gScore[neighbor] = tentativeGScore;
                    fScore[neighbor] = gScore[neighbor] + heuristic(neighbor, endNode);
                });

                setTimeout(step, 10);
            }

            // 獲取鄰居節點
            function getNeighbors(index) {
                const neighbors = [];
                const x = index % 25;
                const y = Math.floor(index / 25);

                if (x > 0) neighbors.push(index - 1);
                if (x < 24) neighbors.push(index + 1);
                if (y > 0) neighbors.push(index - 25);
                if (y < 24) neighbors.push(index + 25);

                return neighbors;
            }

            // 重建路徑
            function reconstructPath(cameFrom, current) {
                const path = [current];
                while (cameFrom[current] !== undefined) {
                    current = cameFrom[current];
                    path.unshift(current);
                }

                path.forEach((node, i) => {
                    if (node !== startNode && node !== endNode) {
                        setTimeout(() => {
                            cells[node].style.backgroundColor = '#f1c40f';
                        }, i * 50);
                    }
                });
            }

            step();
        }
    </script>
</body>
</html>
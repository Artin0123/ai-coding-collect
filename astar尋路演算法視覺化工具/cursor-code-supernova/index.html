<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f8f9fa;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(25, 20px);
            grid-template-rows: repeat(25, 20px);
            gap: 1px;
            background-color: #ccc;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .cell {
            width: 20px;
            height: 20px;
            background-color: #fdfdfd;
            border: 1px solid #ccc;
            cursor: pointer;
        }

        .cell.start {
            background-color: #2ecc71;
        }

        .cell.end {
            background-color: #e74c3c;
        }

        .cell.wall {
            background-color: #34495e;
        }

        .cell.open {
            background-color: #aed6f1;
        }

        .cell.closed {
            background-color: #f5cba7;
        }

        .cell.path {
            background-color: #f1c40f;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover:not(:disabled) {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>A* Pathfinding Visualizer</h1>

    <div class="grid-container" id="gridContainer"></div>

    <div class="controls">
        <button id="findPathBtn">開始尋路</button>
        <button id="resetBtn">重設</button>
    </div>

    <script>
        // 網格設定
        const ROWS = 25;
        const COLS = 25;
        const DELAY = 10; // 每步延遲10ms

        // DOM 元素
        const gridContainer = document.getElementById('gridContainer');
        const findPathBtn = document.getElementById('findPathBtn');
        const resetBtn = document.getElementById('resetBtn');

        // 網格狀態
        let grid = [];
        let startNode = null;
        let endNode = null;
        let isSettingStart = true;
        let isDrawingWalls = false;
        let isFindingPath = false;

        // 建立網格
        function createGrid() {
            gridContainer.innerHTML = '';
            grid = [];

            for (let row = 0; row < ROWS; row++) {
                const currentRow = [];
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    // 滑鼠事件
                    cell.addEventListener('mousedown', handleCellMouseDown);
                    cell.addEventListener('mouseenter', handleCellMouseEnter);
                    cell.addEventListener('mouseup', handleCellMouseUp);

                    gridContainer.appendChild(cell);
                    currentRow.push({
                        element: cell,
                        row: row,
                        col: col,
                        isStart: false,
                        isEnd: false,
                        isWall: false,
                        g: 0,
                        h: 0,
                        f: 0,
                        parent: null
                    });
                }
                grid.push(currentRow);
            }
        }

        // 處理滑鼠點擊單元格
        function handleCellMouseDown(e) {
            if (isFindingPath) return;

            const cell = e.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // 如果是設定起點或終點
            if (!startNode || (!endNode && !grid[row][col].isStart)) {
                if (isSettingStart || !startNode) {
                    // 設定起點
                    if (startNode) {
                        startNode.element.className = 'cell';
                        startNode.isStart = false;
                    }
                    startNode = grid[row][col];
                    startNode.isStart = true;
                    startNode.element.className = 'cell start';
                    isSettingStart = false;
                } else {
                    // 設定終點
                    endNode = grid[row][col];
                    endNode.isEnd = true;
                    endNode.element.className = 'cell end';
                }
            } else {
                // 開始繪製障礙物
                isDrawingWalls = true;
                toggleWall(row, col);
            }
        }

        // 處理滑鼠進入單元格
        function handleCellMouseEnter(e) {
            if (isFindingPath) return;

            const cell = e.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            if (isDrawingWalls && !grid[row][col].isStart && !grid[row][col].isEnd) {
                toggleWall(row, col);
            }
        }

        // 處理滑鼠釋放
        function handleCellMouseUp() {
            isDrawingWalls = false;
        }

        // 切換障礙物
        function toggleWall(row, col) {
            const cell = grid[row][col];
            if (cell.isStart || cell.isEnd) return;

            cell.isWall = !cell.isWall;
            cell.element.className = cell.isWall ? 'cell wall' : 'cell';
        }

        // 重設網格
        function resetGrid() {
            isFindingPath = false;
            findPathBtn.disabled = false;
            isSettingStart = true;

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = grid[row][col];
                    cell.isWall = false;
                    cell.g = 0;
                    cell.h = 0;
                    cell.f = 0;
                    cell.parent = null;
                    cell.element.className = cell.isStart ? 'cell start' :
                                           cell.isEnd ? 'cell end' : 'cell';
                }
            }
        }

        // 計算曼哈頓距離
        function manhattanDistance(node1, node2) {
            return Math.abs(node1.row - node2.row) + Math.abs(node1.col - node2.col);
        }

        // 取得相鄰節點
        function getNeighbors(node) {
            const neighbors = [];
            const directions = [
                {row: -1, col: 0}, // 上
                {row: 1, col: 0},  // 下
                {row: 0, col: -1}, // 左
                {row: 0, col: 1}   // 右
            ];

            directions.forEach(dir => {
                const newRow = node.row + dir.row;
                const newCol = node.col + dir.col;

                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                    const neighbor = grid[newRow][newCol];
                    if (!neighbor.isWall) {
                        neighbors.push(neighbor);
                    }
                }
            });

            return neighbors;
        }

        // A* 演算法
        async function aStar() {
            if (!startNode || !endNode) {
                alert('請先設定起點和終點！');
                return;
            }

            isFindingPath = true;
            findPathBtn.disabled = true;

            const openSet = [startNode];
            const closedSet = new Set();

            startNode.g = 0;
            startNode.h = manhattanDistance(startNode, endNode);
            startNode.f = startNode.g + startNode.h;

            while (openSet.length > 0) {
                // 找到 f 值最小的節點
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();

                // 標記為封閉列表
                if (!current.isStart && !current.isEnd) {
                    current.element.className = 'cell closed';
                }
                closedSet.add(current);

                // 如果到達終點
                if (current === endNode) {
                    await drawPath(current);
                    return;
                }

                const neighbors = getNeighbors(current);

                for (const neighbor of neighbors) {
                    if (closedSet.has(neighbor)) continue;

                    const tentativeG = current.g + 1;

                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);

                        // 標記為開放列表
                        if (!neighbor.isStart && !neighbor.isEnd) {
                            neighbor.element.className = 'cell open';
                        }
                    } else if (tentativeG >= neighbor.g) {
                        continue;
                    }

                    neighbor.parent = current;
                    neighbor.g = tentativeG;
                    neighbor.h = manhattanDistance(neighbor, endNode);
                    neighbor.f = neighbor.g + neighbor.h;

                    await new Promise(resolve => setTimeout(resolve, DELAY));
                }
            }

            // 找不到路徑
            alert('找不到路徑！');
            isFindingPath = false;
            findPathBtn.disabled = false;
        }

        // 繪製路徑
        async function drawPath(endNode) {
            const path = [];
            let current = endNode;

            while (current !== startNode) {
                path.push(current);
                current = current.parent;
            }

            // 反向繪製路徑
            for (let i = path.length - 1; i >= 0; i--) {
                const node = path[i];
                if (!node.isStart && !node.isEnd) {
                    node.element.className = 'cell path';
                }
                await new Promise(resolve => setTimeout(resolve, DELAY));
            }

            isFindingPath = false;
            findPathBtn.disabled = false;
        }

        // 事件監聽器
        findPathBtn.addEventListener('click', aStar);
        resetBtn.addEventListener('click', resetGrid);

        // 初始化網格
        createGrid();
    </script>
</body>
</html>

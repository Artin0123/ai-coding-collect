<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #ecf0f1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-align: center;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(25, 20px);
            grid-template-rows: repeat(25, 20px);
            gap: 0;
            border: 2px solid #34495e;
            background-color: white;
            margin-bottom: 30px;
        }

        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
            cursor: pointer;
            transition: background-color 0.1s ease;
        }

        .cell.start {
            background-color: #2ecc71;
        }

        .cell.end {
            background-color: #e74c3c;
        }

        .cell.wall {
            background-color: #34495e;
        }

        .cell.open {
            background-color: #aed6f1;
        }

        .cell.closed {
            background-color: #f5cba7;
        }

        .cell.path {
            background-color: #f1c40f;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        button:hover:not(:disabled) {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .status {
            margin-top: 20px;
            font-size: 18px;
            color: #2c3e50;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>A* Pathfinding Visualizer</h1>
    
    <div class="grid-container" id="grid"></div>
    
    <div class="controls">
        <button id="findPathBtn">開始尋路 (Find Path)</button>
        <button id="resetBtn">重設 (Reset)</button>
    </div>
    
    <div class="status" id="status">請先設定起點和終點</div>

    <script>
        class AStarVisualizer {
            constructor() {
                this.gridSize = 25;
                this.grid = [];
                this.startNode = null;
                this.endNode = null;
                this.isSettingStart = true;
                this.isSettingEnd = false;
                this.isDrawingWalls = false;
                this.isRunning = false;
                
                this.initializeGrid();
                this.setupEventListeners();
            }

            initializeGrid() {
                const gridContainer = document.getElementById('grid');
                gridContainer.innerHTML = '';
                
                for (let row = 0; row < this.gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        this.grid[row][col] = {
                            element: cell,
                            row: row,
                            col: col,
                            isWall: false,
                            isStart: false,
                            isEnd: false,
                            gCost: 0,
                            hCost: 0,
                            fCost: 0,
                            parent: null
                        };
                        
                        gridContainer.appendChild(cell);
                    }
                }
            }

            setupEventListeners() {
                const gridContainer = document.getElementById('grid');
                const findPathBtn = document.getElementById('findPathBtn');
                const resetBtn = document.getElementById('resetBtn');

                gridContainer.addEventListener('click', (e) => {
                    if (this.isRunning) return;
                    
                    const cell = e.target;
                    if (!cell.classList.contains('cell')) return;
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if (this.isSettingStart) {
                        this.setStartNode(row, col);
                    } else if (this.isSettingEnd) {
                        this.setEndNode(row, col);
                    }
                });

                gridContainer.addEventListener('mousedown', (e) => {
                    if (this.isRunning || this.isSettingStart || this.isSettingEnd) return;
                    
                    const cell = e.target;
                    if (!cell.classList.contains('cell')) return;
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if (this.grid[row][col].isStart || this.grid[row][col].isEnd) return;
                    
                    this.isDrawingWalls = true;
                    this.toggleWall(row, col);
                });

                gridContainer.addEventListener('mouseover', (e) => {
                    if (!this.isDrawingWalls || this.isRunning) return;
                    
                    const cell = e.target;
                    if (!cell.classList.contains('cell')) return;
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if (this.grid[row][col].isStart || this.grid[row][col].isEnd) return;
                    
                    this.toggleWall(row, col);
                });

                document.addEventListener('mouseup', () => {
                    this.isDrawingWalls = false;
                });

                findPathBtn.addEventListener('click', () => {
                    this.findPath();
                });

                resetBtn.addEventListener('click', () => {
                    this.reset();
                });
            }

            setStartNode(row, col) {
                if (this.startNode) {
                    this.startNode.element.classList.remove('start');
                    this.startNode.isStart = false;
                }
                
                this.startNode = this.grid[row][col];
                this.startNode.isStart = true;
                this.startNode.element.classList.add('start');
                
                this.isSettingStart = false;
                this.isSettingEnd = true;
                document.getElementById('status').textContent = '請設定終點';
            }

            setEndNode(row, col) {
                if (this.endNode) {
                    this.endNode.element.classList.remove('end');
                    this.endNode.isEnd = false;
                }
                
                this.endNode = this.grid[row][col];
                this.endNode.isEnd = true;
                this.endNode.element.classList.add('end');
                
                this.isSettingEnd = false;
                document.getElementById('status').textContent = '可以開始繪製障礙物或點擊「開始尋路」';
            }

            toggleWall(row, col) {
                const node = this.grid[row][col];
                if (node.isStart || node.isEnd) return;
                
                node.isWall = !node.isWall;
                node.element.classList.toggle('wall', node.isWall);
            }

            reset() {
                this.isRunning = false;
                this.isSettingStart = true;
                this.isSettingEnd = false;
                this.isDrawingWalls = false;
                this.startNode = null;
                this.endNode = null;
                
                document.getElementById('findPathBtn').disabled = false;
                document.getElementById('status').textContent = '請先設定起點和終點';
                
                this.initializeGrid();
            }

            async findPath() {
                if (!this.startNode || !this.endNode) {
                    alert('請先設定起點和終點！');
                    return;
                }

                this.isRunning = true;
                document.getElementById('findPathBtn').disabled = true;
                document.getElementById('status').textContent = '正在尋找路徑...';

                // 重置所有節點狀態
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const node = this.grid[row][col];
                        node.element.classList.remove('open', 'closed', 'path');
                        node.gCost = 0;
                        node.hCost = 0;
                        node.fCost = 0;
                        node.parent = null;
                    }
                }

                const openSet = [];
                const closedSet = new Set();
                
                // 計算起點的啟發式成本
                this.startNode.hCost = this.heuristic(this.startNode, this.endNode);
                this.startNode.fCost = this.startNode.hCost;
                
                openSet.push(this.startNode);

                while (openSet.length > 0) {
                    // 找到 fCost 最小的節點
                    let currentNode = openSet[0];
                    let currentIndex = 0;
                    
                    for (let i = 1; i < openSet.length; i++) {
                        if (openSet[i].fCost < currentNode.fCost || 
                            (openSet[i].fCost === currentNode.fCost && openSet[i].hCost < currentNode.hCost)) {
                            currentNode = openSet[i];
                            currentIndex = i;
                        }
                    }

                    // 從開放列表中移除當前節點
                    openSet.splice(currentIndex, 1);
                    closedSet.add(currentNode);

                    // 標示當前節點為已檢查
                    if (currentNode !== this.startNode && currentNode !== this.endNode) {
                        currentNode.element.classList.add('closed');
                    }

                    // 檢查是否到達終點
                    if (currentNode === this.endNode) {
                        await this.reconstructPath(currentNode);
                        document.getElementById('status').textContent = '路徑已找到！';
                        this.isRunning = false;
                        document.getElementById('findPathBtn').disabled = false;
                        return;
                    }

                    // 檢查相鄰節點
                    const neighbors = this.getNeighbors(currentNode);
                    
                    for (const neighbor of neighbors) {
                        if (closedSet.has(neighbor) || neighbor.isWall) {
                            continue;
                        }

                        const tentativeGCost = currentNode.gCost + 1;
                        
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                            neighbor.element.classList.add('open');
                        } else if (tentativeGCost >= neighbor.gCost) {
                            continue;
                        }

                        neighbor.parent = currentNode;
                        neighbor.gCost = tentativeGCost;
                        neighbor.hCost = this.heuristic(neighbor, this.endNode);
                        neighbor.fCost = neighbor.gCost + neighbor.hCost;
                    }

                    // 添加延遲以便視覺化
                    await this.sleep(10);
                }

                // 沒有找到路徑
                document.getElementById('status').textContent = '無法找到路徑！';
                this.isRunning = false;
                document.getElementById('findPathBtn').disabled = false;
            }

            getNeighbors(node) {
                const neighbors = [];
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1] // 上下左右
                ];

                for (const [dr, dc] of directions) {
                    const newRow = node.row + dr;
                    const newCol = node.col + dc;
                    
                    if (newRow >= 0 && newRow < this.gridSize && 
                        newCol >= 0 && newCol < this.gridSize) {
                        neighbors.push(this.grid[newRow][newCol]);
                    }
                }

                return neighbors;
            }

            heuristic(nodeA, nodeB) {
                // 曼哈頓距離
                return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);
            }

            async reconstructPath(node) {
                const path = [];
                let current = node;
                
                while (current !== null) {
                    path.unshift(current);
                    current = current.parent;
                }

                // 視覺化路徑
                for (let i = 0; i < path.length; i++) {
                    const pathNode = path[i];
                    if (pathNode !== this.startNode && pathNode !== this.endNode) {
                        pathNode.element.classList.remove('open', 'closed');
                        pathNode.element.classList.add('path');
                    }
                    await this.sleep(50);
                }
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // 初始化應用
        document.addEventListener('DOMContentLoaded', () => {
            new AStarVisualizer();
        });
    </script>
</body>
</html>

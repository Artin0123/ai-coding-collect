<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f8f9fa;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2rem;
            text-align: center;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(25, 20px);
            grid-template-rows: repeat(25, 20px);
            gap: 0;
            border: 2px solid #34495e;
            background-color: white;
        }

        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
            cursor: pointer;
            transition: background-color 0.1s ease;
        }

        .cell:hover {
            opacity: 0.8;
        }

        .cell.start {
            background-color: #2ecc71;
        }

        .cell.end {
            background-color: #e74c3c;
        }

        .cell.wall {
            background-color: #34495e;
        }

        .cell.open {
            background-color: #aed6f1;
        }

        .cell.closed {
            background-color: #f5cba7;
        }

        .cell.path {
            background-color: #f1c40f;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .btn:hover:not(:disabled) {
            background-color: #2980b9;
        }

        .btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .instructions {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 10px;
            max-width: 500px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>A* Pathfinding Visualizer</h1>
        <div class="instructions">
            點擊設定起點，再點擊設定終點，然後拖曳滑鼠繪製障礙物
        </div>
        <div class="grid-container" id="grid"></div>
        <div class="controls">
            <button class="btn" id="findPathBtn">開始尋路 (Find Path)</button>
            <button class="btn" id="resetBtn">重設 (Reset)</button>
        </div>
    </div>

    <script>
        class AStarVisualizer {
            constructor() {
                this.gridSize = 25;
                this.grid = [];
                this.startNode = null;
                this.endNode = null;
                this.isDrawing = false;
                this.isRunning = false;
                this.setupMode = 'start'; // 'start', 'end', 'wall'
                
                this.initializeGrid();
                this.setupEventListeners();
            }

            initializeGrid() {
                const gridContainer = document.getElementById('grid');
                gridContainer.innerHTML = '';
                this.grid = [];

                for (let row = 0; row < this.gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        const node = {
                            row,
                            col,
                            isWall: false,
                            isStart: false,
                            isEnd: false,
                            gCost: Infinity,
                            hCost: 0,
                            fCost: Infinity,
                            parent: null,
                            element: cell
                        };

                        this.grid[row][col] = node;
                        gridContainer.appendChild(cell);

                        cell.addEventListener('mousedown', (e) => this.handleMouseDown(e, node));
                        cell.addEventListener('mouseenter', (e) => this.handleMouseEnter(e, node));
                        cell.addEventListener('mouseup', () => this.handleMouseUp());
                    }
                }

                document.addEventListener('mouseup', () => this.handleMouseUp());
            }

            setupEventListeners() {
                document.getElementById('findPathBtn').addEventListener('click', () => this.startPathfinding());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            }

            handleMouseDown(event, node) {
                if (this.isRunning) return;

                event.preventDefault();
                
                if (this.setupMode === 'start' && !node.isEnd) {
                    this.setStartNode(node);
                } else if (this.setupMode === 'end' && !node.isStart) {
                    this.setEndNode(node);
                } else if (this.setupMode === 'wall' && !node.isStart && !node.isEnd) {
                    this.isDrawing = true;
                    this.toggleWall(node);
                }
            }

            handleMouseEnter(event, node) {
                if (this.isRunning) return;
                
                if (this.isDrawing && this.setupMode === 'wall' && !node.isStart && !node.isEnd) {
                    this.toggleWall(node);
                }
            }

            handleMouseUp() {
                this.isDrawing = false;
            }

            setStartNode(node) {
                if (this.startNode) {
                    this.startNode.isStart = false;
                    this.startNode.element.classList.remove('start');
                }
                
                node.isStart = true;
                node.element.classList.add('start');
                this.startNode = node;
                this.setupMode = 'end';
                this.updateInstructions();
            }

            setEndNode(node) {
                if (this.endNode) {
                    this.endNode.isEnd = false;
                    this.endNode.element.classList.remove('end');
                }
                
                node.isEnd = true;
                node.element.classList.add('end');
                this.endNode = node;
                this.setupMode = 'wall';
                this.updateInstructions();
            }

            toggleWall(node) {
                if (node.isStart || node.isEnd) return;
                
                node.isWall = !node.isWall;
                if (node.isWall) {
                    node.element.classList.add('wall');
                } else {
                    node.element.classList.remove('wall');
                }
            }

            updateInstructions() {
                const instructions = document.querySelector('.instructions');
                if (this.setupMode === 'start') {
                    instructions.textContent = '點擊設定起點';
                } else if (this.setupMode === 'end') {
                    instructions.textContent = '點擊設定終點';
                } else {
                    instructions.textContent = '拖曳滑鼠繪製障礙物，然後點擊「開始尋路」';
                }
            }

            manhattanDistance(nodeA, nodeB) {
                return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);
            }

            getNeighbors(node) {
                const neighbors = [];
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1]
                ];

                for (const [dRow, dCol] of directions) {
                    const newRow = node.row + dRow;
                    const newCol = node.col + dCol;

                    if (newRow >= 0 && newRow < this.gridSize && 
                        newCol >= 0 && newCol < this.gridSize) {
                        neighbors.push(this.grid[newRow][newCol]);
                    }
                }

                return neighbors;
            }

            async startPathfinding() {
                if (!this.startNode || !this.endNode || this.isRunning) return;

                this.isRunning = true;
                document.getElementById('findPathBtn').disabled = true;

                this.clearVisualization();

                const openSet = [this.startNode];
                const closedSet = new Set();

                this.startNode.gCost = 0;
                this.startNode.hCost = this.manhattanDistance(this.startNode, this.endNode);
                this.startNode.fCost = this.startNode.gCost + this.startNode.hCost;

                while (openSet.length > 0) {
                    openSet.sort((a, b) => a.fCost - b.fCost);
                    const currentNode = openSet.shift();

                    if (currentNode === this.endNode) {
                        await this.reconstructPath(currentNode);
                        this.isRunning = false;
                        document.getElementById('findPathBtn').disabled = false;
                        return;
                    }

                    closedSet.add(currentNode);
                    if (!currentNode.isStart && !currentNode.isEnd) {
                        currentNode.element.classList.add('closed');
                    }

                    const neighbors = this.getNeighbors(currentNode);
                    
                    for (const neighbor of neighbors) {
                        if (neighbor.isWall || closedSet.has(neighbor)) continue;

                        const tentativeGCost = currentNode.gCost + 1;

                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                            if (!neighbor.isStart && !neighbor.isEnd) {
                                neighbor.element.classList.add('open');
                            }
                        } else if (tentativeGCost >= neighbor.gCost) {
                            continue;
                        }

                        neighbor.parent = currentNode;
                        neighbor.gCost = tentativeGCost;
                        neighbor.hCost = this.manhattanDistance(neighbor, this.endNode);
                        neighbor.fCost = neighbor.gCost + neighbor.hCost;
                    }

                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                alert('無法找到路徑！');
                this.isRunning = false;
                document.getElementById('findPathBtn').disabled = false;
            }

            async reconstructPath(endNode) {
                const path = [];
                let currentNode = endNode;

                while (currentNode !== null) {
                    path.unshift(currentNode);
                    currentNode = currentNode.parent;
                }

                for (let i = 1; i < path.length - 1; i++) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    path[i].element.classList.remove('open', 'closed');
                    path[i].element.classList.add('path');
                }
            }

            clearVisualization() {
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const node = this.grid[row][col];
                        node.element.classList.remove('open', 'closed', 'path');
                        node.gCost = Infinity;
                        node.hCost = 0;
                        node.fCost = Infinity;
                        node.parent = null;
                    }
                }
            }

            reset() {
                if (this.isRunning) return;

                this.startNode = null;
                this.endNode = null;
                this.setupMode = 'start';
                this.updateInstructions();

                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const node = this.grid[row][col];
                        node.isWall = false;
                        node.isStart = false;
                        node.isEnd = false;
                        node.gCost = Infinity;
                        node.hCost = 0;
                        node.fCost = Infinity;
                        node.parent = null;
                        node.element.className = 'cell';
                    }
                }

                document.getElementById('findPathBtn').disabled = false;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new AStarVisualizer();
        });
    </script>
</body>
</html>
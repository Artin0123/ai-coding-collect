<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>A* Pathfinding Visualizer</title>
<style>
html, body { height: 100%; }
body { margin: 0; display: flex; align-items: center; justify-content: center; background: #ffffff; font-family: Arial, sans-serif; }
#app { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px; }
#title { margin: 0; }
#grid { display: flex; flex-wrap: wrap; width: 525px; height: 525px; box-sizing: content-box; }
.cell { width: 20px; height: 20px; box-sizing: border-box; border: 1px solid #ccc; background: #fdfdfd; }
.controls { display: flex; gap: 10px; }
.button { background: #3498db; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
.button:disabled { opacity: 0.6; cursor: not-allowed; }
.cell.start { background: #2ecc71; }
.cell.end { background: #e74c3c; }
.cell.wall { background: #34495e; }
.cell.open { background: #aed6f1; }
.cell.closed { background: #f5cba7; }
.cell.path { background: #f1c40f; }
</style>
</head>
<body>
<div id="app">
<h1 id="title">A* Pathfinding Visualizer</h1>
<div id="grid"></div>
<div class="controls">
<button id="find" class="button">Find Path</button>
<button id="reset" class="button">Reset</button>
</div>
</div>
<script>
const rows = 25;
const cols = 25;
const gridEl = document.getElementById('grid');
const findBtn = document.getElementById('find');
const resetBtn = document.getElementById('reset');
let grid = [];
let start = null;
let end = null;
let isMouseDown = false;
let hasSetStart = false;
let hasSetEnd = false;
let running = false;
for (let r = 0; r < rows; r++) {
  const row = [];
  for (let c = 0; c < cols; c++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.row = r;
    cell.dataset.col = c;
    cell.addEventListener('mousedown', onCellMouseDown);
    cell.addEventListener('mouseenter', onCellMouseEnter);
    cell.addEventListener('mouseup', onCellMouseUp);
    cell.addEventListener('click', onCellClick);
    gridEl.appendChild(cell);
    row.push({ r, c, wall: false, el: cell });
  }
  grid.push(row);
}
window.addEventListener('mouseup', () => { isMouseDown = false; });
function resetColors() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const el = grid[r][c].el;
      el.classList.remove('start','end','wall','open','closed','path');
    }
  }
}
function clearAll() {
  running = false;
  hasSetStart = false;
  hasSetEnd = false;
  start = null;
  end = null;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      grid[r][c].wall = false;
    }
  }
  resetColors();
  findBtn.disabled = false;
}
resetBtn.addEventListener('click', clearAll);
function onCellClick(e) {
  if (running) return;
  const el = e.currentTarget;
  const r = parseInt(el.dataset.row, 10);
  const c = parseInt(el.dataset.col, 10);
  const cell = grid[r][c];
  if (!hasSetStart) {
    start = cell;
    hasSetStart = true;
    cell.el.classList.add('start');
    cell.wall = false;
    return;
  }
  if (!hasSetEnd) {
    if (cell === start) return;
    end = cell;
    hasSetEnd = true;
    cell.el.classList.add('end');
    cell.wall = false;
    return;
  }
}
function onCellMouseDown(e) {
  if (running) return;
  isMouseDown = true;
  drawWall(e.currentTarget);
}
function onCellMouseEnter(e) {
  if (running) return;
  if (!isMouseDown) return;
  drawWall(e.currentTarget);
}
function onCellMouseUp() { isMouseDown = false; }
function drawWall(el) {
  if (!hasSetStart || !hasSetEnd) return;
  const r = parseInt(el.dataset.row, 10);
  const c = parseInt(el.dataset.col, 10);
  const cell = grid[r][c];
  if (cell === start || cell === end) return;
  cell.wall = true;
  cell.el.classList.add('wall');
  cell.el.classList.remove('open','closed','path');
}
function heuristic(a, b) { return Math.abs(a.r - b.r) + Math.abs(a.c - b.c); }
function neighbors(node) {
  const res = [];
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dr, dc] of dirs) {
    const nr = node.r + dr;
    const nc = node.c + dc;
    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
      const n = grid[nr][nc];
      if (!n.wall) res.push(n);
    }
  }
  return res;
}
function key(n) { return n.r + ',' + n.c; }
function reconstruct(cameFrom, current) {
  const path = [];
  while (current && cameFrom[key(current)]) {
    path.push(current);
    current = cameFrom[key(current)];
  }
  path.push(start);
  for (const n of path) {
    if (n !== start && n !== end) {
      n.el.classList.remove('open','closed');
      n.el.classList.add('path');
    }
  }
}
function aStarVisual() {
  if (!hasSetStart || !hasSetEnd) return;
  if (running) return;
  running = true;
  findBtn.disabled = true;
  const openSet = [];
  const closedSet = new Set();
  const cameFrom = {};
  const gScore = {};
  const fScore = {};
  gScore[key(start)] = 0;
  fScore[key(start)] = heuristic(start, end);
  openSet.push(start);
  start.el.classList.add('open');
  function step() {
    if (openSet.length === 0) {
      running = false;
      findBtn.disabled = false;
      return;
    }
    let bestIdx = 0;
    let bestF = Infinity;
    for (let i = 0; i < openSet.length; i++) {
      const k = key(openSet[i]);
      const f = fScore[k] ?? Infinity;
      if (f < bestF) { bestF = f; bestIdx = i; }
    }
    const current = openSet.splice(bestIdx, 1)[0];
    current.el.classList.remove('open');
    closedSet.add(key(current));
    if (current !== start && current !== end) current.el.classList.add('closed');
    if (current === end) {
      reconstruct(cameFrom, current);
      running = false;
      findBtn.disabled = false;
      return;
    }
    const curG = gScore[key(current)] ?? Infinity;
    for (const n of neighbors(current)) {
      const nk = key(n);
      if (closedSet.has(nk)) continue;
      const tentativeG = curG + 1;
      const existing = gScore[nk];
      if (existing === undefined || tentativeG < existing) {
        cameFrom[nk] = current;
        gScore[nk] = tentativeG;
        fScore[nk] = tentativeG + heuristic(n, end);
        if (!openSet.some(x => x === n)) {
          openSet.push(n);
          if (n !== start && n !== end) n.el.classList.add('open');
        }
      }
    }
    setTimeout(step, 10);
  }
  step();
}
findBtn.addEventListener('click', aStarVisual);
</script>
</body>
</html>
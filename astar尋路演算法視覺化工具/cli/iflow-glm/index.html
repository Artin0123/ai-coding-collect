<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(25, 20px);
            grid-template-rows: repeat(25, 20px);
            gap: 0;
            border: 1px solid #ccc;
            background-color: #fff;
        }

        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
            box-sizing: border-box;
        }

        .start {
            background-color: #2ecc71;
        }

        .end {
            background-color: #e74c3c;
        }

        .wall {
            background-color: #34495e;
        }

        .open {
            background-color: #aed6f1;
        }

        .closed {
            background-color: #f5cba7;
        }

        .path {
            background-color: #f1c40f;
        }

        #controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <h1>A* Pathfinding Visualizer</h1>
    <div id="grid-container"></div>
    <div id="controls">
        <button id="start-btn">開始尋路 (Find Path)</button>
        <button id="reset-btn">重設 (Reset)</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridContainer = document.getElementById('grid-container');
            const startBtn = document.getElementById('start-btn');
            const resetBtn = document.getElementById('reset-btn');
            
            const gridSize = 25;
            const cellSize = 20;
            
            let grid = [];
            let startNode = null;
            let endNode = null;
            let isDrawing = false;
            let startSet = false;
            let endSet = false;
            
            // 初始化網格
            function initGrid() {
                gridContainer.innerHTML = '';
                grid = [];
                
                for (let row = 0; row < gridSize; row++) {
                    grid[row] = [];
                    for (let col = 0; col < gridSize; col++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        cell.addEventListener('mousedown', handleCellMouseDown);
                        cell.addEventListener('mouseenter', handleCellMouseEnter);
                        cell.addEventListener('mouseup', handleCellMouseUp);
                        
                        gridContainer.appendChild(cell);
                        
                        grid[row][col] = {
                            element: cell,
                            row: row,
                            col: col,
                            isStart: false,
                            isEnd: false,
                            isWall: false,
                            isOpen: false,
                            isClosed: false,
                            isPath: false,
                            f: 0,
                            g: 0,
                            h: 0,
                            parent: null
                        };
                    }
                }
                
                startSet = false;
                endSet = false;
                startNode = null;
                endNode = null;
            }
            
            // 處理滑鼠按下事件
            function handleCellMouseDown(e) {
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                const node = grid[row][col];
                
                if (!startSet) {
                    // 設置起點
                    node.isStart = true;
                    node.element.classList.add('start');
                    startNode = node;
                    startSet = true;
                } else if (!endSet && !node.isStart) {
                    // 設置終點
                    node.isEnd = true;
                    node.element.classList.add('end');
                    endNode = node;
                    endSet = true;
                } else if (startSet && endSet && !node.isStart && !node.isEnd) {
                    // 開始繪製牆壁
                    isDrawing = true;
                    node.isWall = true;
                    node.element.classList.add('wall');
                }
            }
            
            // 處理滑鼠進入事件
            function handleCellMouseEnter(e) {
                if (isDrawing) {
                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    const node = grid[row][col];
                    
                    if (!node.isStart && !node.isEnd) {
                        node.isWall = true;
                        node.element.classList.add('wall');
                    }
                }
            }
            
            // 處理滑鼠釋放事件
            function handleCellMouseUp() {
                isDrawing = false;
            }
            
            // 計算曼哈頓距離
            function manhattanDistance(nodeA, nodeB) {
                return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);
            }
            
            // 獲取鄰居節點
            function getNeighbors(node) {
                const neighbors = [];
                const { row, col } = node;
                
                if (row > 0) neighbors.push(grid[row - 1][col]);
                if (row < gridSize - 1) neighbors.push(grid[row + 1][col]);
                if (col > 0) neighbors.push(grid[row][col - 1]);
                if (col < gridSize - 1) neighbors.push(grid[row][col + 1]);
                
                return neighbors;
            }
            
            // 重建路徑
            function reconstructPath(node) {
                const path = [];
                let current = node;
                
                while (current !== null) {
                    path.unshift(current);
                    current = current.parent;
                }
                
                return path;
            }
            
            // A* 演算法
            async function astar() {
                if (!startNode || !endNode) {
                    alert('請先設置起點和終點！');
                    return;
                }
                
                // 重置所有節點的狀態
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const node = grid[row][col];
                        node.f = 0;
                        node.g = 0;
                        node.h = 0;
                        node.parent = null;
                        
                        // 清除可視化狀態，但保留牆壁、起點和終點
                        if (!node.isWall && !node.isStart && !node.isEnd) {
                            node.element.classList.remove('open', 'closed', 'path');
                            node.isOpen = false;
                            node.isClosed = false;
                            node.isPath = false;
                        }
                    }
                }
                
                const openSet = [];
                const closedSet = [];
                
                openSet.push(startNode);
                
                while (openSet.length > 0) {
                    // 找到 f 值最小的節點
                    let lowestIndex = 0;
                    for (let i = 0; i < openSet.length; i++) {
                        if (openSet[i].f < openSet[lowestIndex].f) {
                            lowestIndex = i;
                        }
                    }
                    
                    const currentNode = openSet[lowestIndex];
                    
                    // 如果到達終點
                    if (currentNode === endNode) {
                        const path = reconstructPath(endNode);
                        
                        // 顯示最終路徑
                        for (let i = 1; i < path.length - 1; i++) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                            path[i].element.classList.remove('open', 'closed');
                            path[i].element.classList.add('path');
                            path[i].isPath = true;
                        }
                        
                        startBtn.disabled = false;
                        return;
                    }
                    
                    // 從開放列表中移除當前節點，並添加到封閉列表
                    openSet.splice(lowestIndex, 1);
                    closedSet.push(currentNode);
                    
                    // 更新視覺化
                    if (!currentNode.isStart && !currentNode.isEnd) {
                        currentNode.element.classList.remove('open');
                        currentNode.element.classList.add('closed');
                        currentNode.isClosed = true;
                    }
                    
                    // 獲取鄰居節點
                    const neighbors = getNeighbors(currentNode);
                    
                    for (const neighbor of neighbors) {
                        // 如果鄰居是牆壁或在封閉列表中，跳過
                        if (neighbor.isWall || closedSet.includes(neighbor)) {
                            continue;
                        }
                        
                        const tentativeG = currentNode.g + 1;
                        
                        // 如果鄰居不在開放列表中，或者找到更短路徑
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        } else if (tentativeG >= neighbor.g) {
                            continue;
                        }
                        
                        // 更新鄰居節點的值
                        neighbor.parent = currentNode;
                        neighbor.g = tentativeG;
                        neighbor.h = manhattanDistance(neighbor, endNode);
                        neighbor.f = neighbor.g + neighbor.h;
                        
                        // 更新視覺化
                        if (!neighbor.isStart && !neighbor.isEnd && !neighbor.isClosed) {
                            neighbor.element.classList.add('open');
                            neighbor.isOpen = true;
                        }
                    }
                    
                    // 延遲以實現視覺化效果
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                // 如果找不到路徑
                alert('找不到路徑！');
                startBtn.disabled = false;
            }
            
            // 重設網格
            function resetGrid() {
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const node = grid[row][col];
                        node.element.classList.remove('start', 'end', 'wall', 'open', 'closed', 'path');
                        node.isStart = false;
                        node.isEnd = false;
                        node.isWall = false;
                        node.isOpen = false;
                        node.isClosed = false;
                        node.isPath = false;
                        node.f = 0;
                        node.g = 0;
                        node.h = 0;
                        node.parent = null;
                    }
                }
                
                startSet = false;
                endSet = false;
                startNode = null;
                endNode = null;
                startBtn.disabled = false;
            }
            
            // 事件監聽器
            startBtn.addEventListener('click', () => {
                startBtn.disabled = true;
                astar();
            });
            
            resetBtn.addEventListener('click', resetGrid);
            
            // 防止拖動時選中文本
            document.addEventListener('selectstart', (e) => {
                if (isDrawing) {
                    e.preventDefault();
                }
            });
            
            // 初始化網格
            initGrid();
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* 尋路演算法視覺化工具</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f5f5f5;
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(25, 20px);
            grid-template-rows: repeat(25, 20px);
            gap: 0;
            border: 1px solid #ccc;
            margin-bottom: 20px;
        }

        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
            cursor: pointer;
            box-sizing: border-box;
        }

        .cell.start {
            background-color: #2ecc71;
        }

        .cell.end {
            background-color: #e74c3c;
        }

        .cell.wall {
            background-color: #34495e;
        }

        .cell.open {
            background-color: #aed6f1;
        }

        .cell.closed {
            background-color: #f5cba7;
        }

        .cell.path {
            background-color: #f1c40f;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover:not(:disabled) {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>A* Pathfinding Visualizer</h1>
    <div class="grid-container" id="grid"></div>
    <div class="controls">
        <button id="findPathBtn">開始尋路 (Find Path)</button>
        <button id="resetBtn">重設 (Reset)</button>
    </div>

    <script>
        const GRID_SIZE = 25;
        const DELAY = 10; // 10ms delay between steps

        let grid = [];
        let startNode = null;
        let endNode = null;
        let isDrawingWalls = false;
        let isAlgorithmRunning = false;

        // Node class for A* algorithm
        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.f = 0; // f = g + h
                this.g = 0; // cost from start
                this.h = 0; // heuristic
                this.parent = null;
                this.isWall = false;
                this.isVisited = false;
            }
        }

        // Priority Queue implementation
        class PriorityQueue {
            constructor() {
                this.items = [];
            }

            enqueue(element, priority) {
                const queueElement = { element, priority };
                let added = false;

                for (let i = 0; i < this.items.length; i++) {
                    if (queueElement.priority < this.items[i].priority) {
                        this.items.splice(i, 0, queueElement);
                        added = true;
                        break;
                    }
                }

                if (!added) {
                    this.items.push(queueElement);
                }
            }

            dequeue() {
                return this.items.shift();
            }

            isEmpty() {
                return this.items.length === 0;
            }
        }

        // Initialize grid
        function initGrid() {
            const gridContainer = document.getElementById('grid');
            gridContainer.innerHTML = '';

            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                const row = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const node = new Node(x, y);
                    row.push(node);

                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    gridContainer.appendChild(cell);
                }
                grid.push(row);
            }

            startNode = null;
            endNode = null;
            isAlgorithmRunning = false;
        }

        // Manhattan distance heuristic
        function heuristic(nodeA, nodeB) {
            return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);
        }

        // Get neighbors of a node
        function getNeighbors(node) {
            const neighbors = [];
            const { x, y } = node;

            // Up
            if (y > 0) neighbors.push(grid[y - 1][x]);
            // Down
            if (y < GRID_SIZE - 1) neighbors.push(grid[y + 1][x]);
            // Left
            if (x > 0) neighbors.push(grid[y][x - 1]);
            // Right
            if (x < GRID_SIZE - 1) neighbors.push(grid[y][x + 1]);

            return neighbors.filter(neighbor => !neighbor.isWall);
        }

        // Reconstruct path from end node to start node
        function reconstructPath(endNode) {
            const path = [];
            let current = endNode;

            while (current !== null) {
                path.unshift(current);
                current = current.parent;
            }

            return path;
        }

        // A* algorithm with visualization
        function aStar() {
            if (!startNode || !endNode) {
                alert('請先設置起點和終點！');
                return;
            }

            isAlgorithmRunning = true;
            document.getElementById('findPathBtn').disabled = true;

            // Reset visited states and parents
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const node = grid[y][x];
                    node.g = Infinity;
                    node.f = Infinity;
                    node.parent = null;
                    node.isVisited = false;

                    // Reset visual states except walls, start, and end
                    const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                    if (!node.isWall && node !== startNode && node !== endNode) {
                        cell.className = 'cell';
                    }
                }
            }

            const openSet = new PriorityQueue();
            startNode.g = 0;
            startNode.h = heuristic(startNode, endNode);
            startNode.f = startNode.g + startNode.h;
            openSet.enqueue(startNode, startNode.f);

            let stepCount = 0;

            function processStep() {
                if (openSet.isEmpty()) {
                    // No path found
                    isAlgorithmRunning = false;
                    document.getElementById('findPathBtn').disabled = false;
                    return;
                }

                const current = openSet.dequeue().element;

                if (current.isVisited) {
                    setTimeout(processStep, DELAY);
                    return;
                }

                current.isVisited = true;

                // Update visual state
                if (current !== startNode && current !== endNode) {
                    const cell = document.querySelector(`[data-x="${current.x}"][data-y="${current.y}"]`);
                    cell.classList.add('closed');
                }

                if (current === endNode) {
                    // Path found
                    const path = reconstructPath(current);

                    // Visualize path
                    path.forEach((node, index) => {
                        setTimeout(() => {
                            if (node !== startNode && node !== endNode) {
                                const cell = document.querySelector(`[data-x="${node.x}"][data-y="${node.y}"]`);
                                cell.className = 'cell path';
                            }
                            if (index === path.length - 1) {
                                isAlgorithmRunning = false;
                                document.getElementById('findPathBtn').disabled = false;
                            }
                        }, index * DELAY);
                    });
                    return;
                }

                const neighbors = getNeighbors(current);

                for (const neighbor of neighbors) {
                    if (neighbor.isVisited) continue;

                    const tentativeG = current.g + 1; // Assuming cost of 1 for each move

                    if (tentativeG < neighbor.g) {
                        neighbor.parent = current;
                        neighbor.g = tentativeG;
                        neighbor.h = heuristic(neighbor, endNode);
                        neighbor.f = neighbor.g + neighbor.h;

                        // Add to open set if not already there
                        openSet.enqueue(neighbor, neighbor.f);

                        // Update visual state for open set
                        if (neighbor !== startNode && neighbor !== endNode) {
                            const cell = document.querySelector(`[data-x="${neighbor.x}"][data-y="${neighbor.y}"]`);
                            if (!cell.classList.contains('closed')) {
                                cell.classList.add('open');
                            }
                        }
                    }
                }

                setTimeout(processStep, DELAY);
            }

            processStep();
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            initGrid();

            let clickCount = 0;

            document.getElementById('grid').addEventListener('mousedown', (e) => {
                if (isAlgorithmRunning) return;

                const cell = e.target;
                if (!cell.classList.contains('cell')) return;

                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const node = grid[y][x];

                if (clickCount === 0) {
                    // Set start node
                    if (startNode) {
                        const oldCell = document.querySelector(`[data-x="${startNode.x}"][data-y="${startNode.y}"]`);
                        oldCell.classList.remove('start');
                    }
                    startNode = node;
                    cell.classList.add('start');
                    clickCount++;
                } else if (clickCount === 1) {
                    // Set end node
                    if (endNode) {
                        const oldCell = document.querySelector(`[data-x="${endNode.x}"][data-y="${endNode.y}"]`);
                        oldCell.classList.remove('end');
                    }
                    endNode = node;
                    cell.classList.add('end');
                    clickCount++;
                } else {
                    // Start drawing walls
                    if (node !== startNode && node !== endNode) {
                        node.isWall = !node.isWall;
                        cell.classList.toggle('wall');
                        isDrawingWalls = node.isWall;
                    }
                }
            });

            document.getElementById('grid').addEventListener('mouseenter', (e) => {
                if (isAlgorithmRunning || !isDrawingWalls) return;

                const cell = e.target;
                if (!cell.classList.contains('cell')) return;

                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const node = grid[y][x];

                if (node !== startNode && node !== endNode && !node.isWall) {
                    node.isWall = true;
                    cell.classList.add('wall');
                }
            });

            document.addEventListener('mouseup', () => {
                isDrawingWalls = false;
            });

            document.getElementById('findPathBtn').addEventListener('click', aStar);

            document.getElementById('resetBtn').addEventListener('click', initGrid);
        });
    </script>
</body>
</html>

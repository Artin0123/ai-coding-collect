<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding Visualizer</title>
    <style>
        :root {
            --cell-size: 20px;
            --grid-width: 25;
            --grid-height: 25;
            --color-default: #fdfdfd;
            --color-start: #2ecc71;
            --color-end: #e74c3c;
            --color-wall: #34495e;
            --color-open: #aed6f1;
            --color-closed: #f5cba7;
            --color-path: #f1c40f;
            --border-color: #ccc;
        }

        html, body {
            height: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f2f5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        h1 {
            margin: 0;
            color: #333;
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(var(--grid-width), var(--cell-size));
            grid-template-rows: repeat(var(--grid-height), var(--cell-size));
            border: 1px solid var(--border-color);
            user-select: none; /* 防止拖曳時選取文字 */
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--color-default);
            border: 1px solid var(--border-color);
            box-sizing: border-box; /* 確保邊框不會增加尺寸 */
        }

        .cell.start { background-color: var(--color-start); }
        .cell.end { background-color: var(--color-end); }
        .cell.wall { background-color: var(--color-wall); }
        .cell.open { background-color: var(--color-open); }
        .cell.closed { background-color: var(--color-closed); }
        .cell.path { background-color: var(--color-path); }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        button:hover:not(:disabled) {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #a9cce3;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <div class="main-container">
        <h1>A* Pathfinding Visualizer</h1>
        <div id="grid-container"></div>
        <div class="controls">
            <button id="start-btn">開始尋路 (Find Path)</button>
            <button id="reset-btn">重設 (Reset)</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const GRID_WIDTH = 25;
            const GRID_HEIGHT = 25;
            const VISUALIZATION_DELAY = 10;

            const gridContainer = document.getElementById('grid-container');
            const startBtn = document.getElementById('start-btn');
            const resetBtn = document.getElementById('reset-btn');

            let grid = [];
            let startNode = null;
            let endNode = null;

            let isSettingStart = true;
            let isSettingEnd = false;
            let isDrawingWalls = false;
            let isMouseDown = false;

            class Node {
                constructor(row, col, element) {
                    this.row = row;
                    this.col = col;
                    this.element = element;
                    this.isWall = false;
                    this.g = Infinity; // Distance from start node
                    this.h = 0;        // Heuristic distance to end node
                    this.f = Infinity; // g + h
                    this.parent = null;
                }

                reset() {
                    this.isWall = false;
                    this.g = Infinity;
                    this.h = 0;
                    this.f = Infinity;
                    this.parent = null;
                    this.element.className = 'cell';
                }

                setAsWall() {
                    if (this !== startNode && this !== endNode) {
                        this.isWall = true;
                        this.element.classList.add('wall');
                    }
                }
            }

            function createGrid() {
                gridContainer.innerHTML = '';
                grid = [];
                for (let row = 0; row < GRID_HEIGHT; row++) {
                    const currentRow = [];
                    for (let col = 0; col < GRID_WIDTH; col++) {
                        const cellElement = document.createElement('div');
                        cellElement.className = 'cell';
                        cellElement.dataset.row = row;
                        cellElement.dataset.col = col;
                        gridContainer.appendChild(cellElement);
                        
                        const node = new Node(row, col, cellElement);
                        currentRow.push(node);

                        cellElement.addEventListener('click', () => handleCellClick(node));
                        cellElement.addEventListener('mousedown', () => handleMouseDown(node));
                        cellElement.addEventListener('mouseenter', () => handleMouseEnter(node));
                    }
                    grid.push(currentRow);
                }
                // Add mouseup listener to the whole document to catch mouse release anywhere
                document.addEventListener('mouseup', handleMouseUp);
            }

            function handleCellClick(node) {
                if (isSettingStart) {
                    startNode = node;
                    node.element.classList.add('start');
                    isSettingStart = false;
                    isSettingEnd = true;
                } else if (isSettingEnd && node !== startNode) {
                    endNode = node;
                    node.element.classList.add('end');
                    isSettingEnd = false;
                    isDrawingWalls = true;
                }
            }

            function handleMouseDown(node) {
                if (isDrawingWalls) {
                    isMouseDown = true;
                    node.setAsWall();
                }
            }

            function handleMouseEnter(node) {
                if (isMouseDown && isDrawingWalls) {
                    node.setAsWall();
                }
            }

            function handleMouseUp() {
                isMouseDown = false;
            }

            function resetGrid() {
                startNode = null;
                endNode = null;
                isSettingStart = true;
                isSettingEnd = false;
                isDrawingWalls = false;
                isMouseDown = false;
                
                for (let row of grid) {
                    for (let node of row) {
                        node.reset();
                    }
                }
                startBtn.disabled = false;
            }

            function manhattanDistance(nodeA, nodeB) {
                return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);
            }

            function getNeighbors(node) {
                const neighbors = [];
                const { row, col } = node;
                if (row > 0) neighbors.push(grid[row - 1][col]);
                if (row < GRID_HEIGHT - 1) neighbors.push(grid[row + 1][col]);
                if (col > 0) neighbors.push(grid[row][col - 1]);
                if (col < GRID_WIDTH - 1) neighbors.push(grid[row][col + 1]);
                return neighbors.filter(neighbor => !neighbor.isWall);
            }

            async function findPath() {
                if (!startNode || !endNode) {
                    alert("請先設定起點和終點！");
                    return;
                }

                startBtn.disabled = true;
                isDrawingWalls = false; // Disable wall drawing during search

                const openSet = [startNode];
                const closedSet = new Set();

                startNode.g = 0;
                startNode.h = manhattanDistance(startNode, endNode);
                startNode.f = startNode.h;

                function visualizeStep() {
                    if (openSet.length === 0) {
                        alert("找不到路徑！");
                        startBtn.disabled = false;
                        return;
                    }

                    // Find the node in openSet with the lowest f score
                    let lowestIndex = 0;
                    for (let i = 1; i < openSet.length; i++) {
                        if (openSet[i].f < openSet[lowestIndex].f) {
                            lowestIndex = i;
                        }
                    }
                    const currentNode = openSet[lowestIndex];

                    // Path found
                    if (currentNode === endNode) {
                        reconstructPath(currentNode);
                        return;
                    }

                    // Move current node from open to closed
                    openSet.splice(lowestIndex, 1);
                    closedSet.add(currentNode);

                    if (currentNode !== startNode) {
                        currentNode.element.classList.add('closed');
                    }

                    const neighbors = getNeighbors(currentNode);
                    for (const neighbor of neighbors) {
                        if (closedSet.has(neighbor)) {
                            continue;
                        }

                        const tentativeG = currentNode.g + 1;

                        let newPathFound = false;
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                            if (neighbor !== endNode) {
                                neighbor.element.classList.add('open');
                            }
                            newPathFound = true;
                        } else if (tentativeG >= neighbor.g) {
                            continue; // This path is not better
                        }

                        // This path is the best until now. Record it.
                        neighbor.parent = currentNode;
                        neighbor.g = tentativeG;
                        neighbor.h = manhattanDistance(neighbor, endNode);
                        neighbor.f = neighbor.g + neighbor.h;
                    }
                    
                    setTimeout(visualizeStep, VISUALIZATION_DELAY);
                }
                
                visualizeStep();
            }

            function reconstructPath(currentNode) {
                const path = [];
                let temp = currentNode;
                while (temp !== null) {
                    path.push(temp);
                    temp = temp.parent;
                }
                drawPath(path.reverse());
            }

            function drawPath(path) {
                for (let i = 0; i < path.length; i++) {
                    const node = path[i];
                    // Use setTimeout to draw the final path sequentially
                    setTimeout(() => {
                        if (node !== startNode && node !== endNode) {
                            node.element.className = 'cell path'; // Override open/closed colors
                        }
                        // Re-enable button after the path is fully drawn
                        if (i === path.length - 1) {
                            startBtn.disabled = false;
                        }
                    }, i * 30);
                }
            }

            startBtn.addEventListener('click', findPath);
            resetBtn.addEventListener('click', resetGrid);

            // Initial setup
            createGrid();
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-TW">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>A* Pathfinding Visualizer</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: Arial, sans-serif;
                background-color: #f8f9fa;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                padding: 20px;
            }

            h1 {
                font-size: 2.5rem;
                color: #2c3e50;
                margin-bottom: 30px;
                text-align: center;
            }

            .grid-container {
                display: grid;
                grid-template-columns: repeat(25, 20px);
                grid-template-rows: repeat(25, 20px);
                gap: 0;
                border: 2px solid #34495e;
                background-color: white;
                margin-bottom: 30px;
            }

            .cell {
                width: 20px;
                height: 20px;
                border: 1px solid #ccc;
                background-color: #fdfdfd;
                cursor: pointer;
                transition: background-color 0.2s;
            }

            .cell.start {
                background-color: #2ecc71;
            }

            .cell.end {
                background-color: #e74c3c;
            }

            .cell.wall {
                background-color: #34495e;
            }

            .cell.open {
                background-color: #aed6f1;
            }

            .cell.closed {
                background-color: #f5cba7;
            }

            .cell.path {
                background-color: #f1c40f;
            }

            .controls {
                display: flex;
                gap: 10px;
                align-items: center;
            }

            button {
                background-color: #3498db;
                color: white;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                transition: background-color 0.3s;
            }

            button:hover:not(:disabled) {
                background-color: #2980b9;
            }

            button:disabled {
                background-color: #bdc3c7;
                cursor: not-allowed;
            }

            .status {
                margin-top: 20px;
                font-size: 18px;
                color: #2c3e50;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <h1>A* Pathfinding Visualizer</h1>

        <div class="grid-container" id="grid"></div>

        <div class="controls">
            <button id="findPathBtn">開始尋路 (Find Path)</button>
            <button id="resetBtn">重設 (Reset)</button>
        </div>

        <div class="status" id="status">點擊網格設置起點，再次點擊設置終點，然後拖曳繪製障礙物</div>

        <script>
            class AStarVisualizer {
                constructor() {
                    this.gridSize = 25;
                    this.grid = [];
                    this.startNode = null;
                    this.endNode = null;
                    this.isDrawing = false;
                    this.isRunning = false;
                    this.setupPhase = 'start'; // 'start', 'end', 'walls'

                    this.initializeGrid();
                    this.setupEventListeners();
                    this.updateStatus();
                }

                initializeGrid() {
                    const gridContainer = document.getElementById('grid');
                    gridContainer.innerHTML = '';
                    this.grid = [];

                    for (let row = 0; row < this.gridSize; row++) {
                        this.grid[row] = [];
                        for (let col = 0; col < this.gridSize; col++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.dataset.row = row;
                            cell.dataset.col = col;

                            const node = {
                                row,
                                col,
                                element: cell,
                                isStart: false,
                                isEnd: false,
                                isWall: false,
                                gScore: Infinity,
                                fScore: Infinity,
                                parent: null,
                                isVisited: false
                            };

                            this.grid[row][col] = node;
                            gridContainer.appendChild(cell);
                        }
                    }
                }

                setupEventListeners() {
                    const gridContainer = document.getElementById('grid');
                    const findPathBtn = document.getElementById('findPathBtn');
                    const resetBtn = document.getElementById('resetBtn');

                    // 網格點擊事件
                    gridContainer.addEventListener('click', (e) => this.handleCellClick(e));
                    gridContainer.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    gridContainer.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                    gridContainer.addEventListener('mouseup', () => this.handleMouseUp());

                    // 按鈕事件
                    findPathBtn.addEventListener('click', () => this.findPath());
                    resetBtn.addEventListener('click', () => this.reset());
                }

                handleCellClick(e) {
                    if (!e.target.classList.contains('cell') || this.isRunning) return;

                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    const node = this.grid[row][col];

                    if (this.setupPhase === 'start' && !node.isWall) {
                        this.setStartNode(node);
                    } else if (this.setupPhase === 'end' && !node.isWall && !node.isStart) {
                        this.setEndNode(node);
                    }
                }

                handleMouseDown(e) {
                    if (!e.target.classList.contains('cell') || this.isRunning || this.setupPhase !== 'walls') return;

                    this.isDrawing = true;
                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    const node = this.grid[row][col];

                    if (!node.isStart && !node.isEnd) {
                        this.toggleWall(node);
                    }
                }

                handleMouseMove(e) {
                    if (!this.isDrawing || !e.target.classList.contains('cell')) return;

                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    const node = this.grid[row][col];

                    if (!node.isStart && !node.isEnd && !node.isWall) {
                        this.toggleWall(node);
                    }
                }

                handleMouseUp() {
                    this.isDrawing = false;
                }

                setStartNode(node) {
                    if (this.startNode) {
                        this.startNode.isStart = false;
                        this.startNode.element.classList.remove('start');
                    }

                    node.isStart = true;
                    node.element.classList.add('start');
                    this.startNode = node;
                    this.setupPhase = 'end';
                    this.updateStatus();
                }

                setEndNode(node) {
                    if (this.endNode) {
                        this.endNode.isEnd = false;
                        this.endNode.element.classList.remove('end');
                    }

                    node.isEnd = true;
                    node.element.classList.add('end');
                    this.endNode = node;
                    this.setupPhase = 'walls';
                    this.updateStatus();
                }

                toggleWall(node) {
                    node.isWall = !node.isWall;
                    node.element.classList.toggle('wall', node.isWall);
                }

                updateStatus() {
                    const status = document.getElementById('status');

                    if (this.setupPhase === 'start') {
                        status.textContent = '點擊網格設置起點';
                    } else if (this.setupPhase === 'end') {
                        status.textContent = '點擊網格設置終點';
                    } else if (this.setupPhase === 'walls') {
                        status.textContent = '拖曳繪製障礙物，然後點擊「開始尋路」';
                    }
                }

                // 計算曼哈頓距離
                manhattanDistance(nodeA, nodeB) {
                    return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);
                }

                // 獲取鄰居節點
                getNeighbors(node) {
                    const neighbors = [];
                    const directions = [
                        [-1, 0], [1, 0], [0, -1], [0, 1] // 上、下、左、右
                    ];

                    for (const [dr, dc] of directions) {
                        const newRow = node.row + dr;
                        const newCol = node.col + dc;

                        if (newRow >= 0 && newRow < this.gridSize &&
                            newCol >= 0 && newCol < this.gridSize) {
                            const neighbor = this.grid[newRow][newCol];
                            if (!neighbor.isWall) {
                                neighbors.push(neighbor);
                            }
                        }
                    }

                    return neighbors;
                }

                // 重建路徑
                reconstructPath(node) {
                    const path = [];
                    let current = node;

                    while (current.parent) {
                        path.push(current);
                        current = current.parent;
                    }

                    return path.reverse();
                }

                // 視覺化路徑
                async visualizePath(path) {
                    for (const node of path) {
                        if (!node.isStart && !node.isEnd) {
                            node.element.classList.remove('open', 'closed');
                            node.element.classList.add('path');
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                }

                // A* 演算法主要實現
                async findPath() {
                    if (!this.startNode || !this.endNode || this.isRunning) return;

                    this.isRunning = true;
                    document.getElementById('findPathBtn').disabled = true;
                    document.getElementById('status').textContent = '正在尋找路徑...';

                    // 清除之前的視覺化
                    this.clearVisualization();

                    const openSet = [this.startNode];
                    const closedSet = new Set();

                    // 初始化起點
                    this.startNode.gScore = 0;
                    this.startNode.fScore = this.manhattanDistance(this.startNode, this.endNode);

                    while (openSet.length > 0) {
                        // 找到 fScore 最低的節點
                        let currentIndex = 0;
                        for (let i = 1; i < openSet.length; i++) {
                            if (openSet[i].fScore < openSet[currentIndex].fScore) {
                                currentIndex = i;
                            }
                        }

                        const current = openSet.splice(currentIndex, 1)[0];

                        // 如果到達終點
                        if (current === this.endNode) {
                            const path = this.reconstructPath(current);
                            await this.visualizePath(path);
                            document.getElementById('status').textContent = `路徑找到！長度：${path.length}`;
                            this.isRunning = false;
                            document.getElementById('findPathBtn').disabled = false;
                            return;
                        }

                        closedSet.add(current);

                        // 視覺化當前節點（除非是起點或終點）
                        if (!current.isStart && !current.isEnd) {
                            current.element.classList.remove('open');
                            current.element.classList.add('closed');
                        }

                        // 檢查所有鄰居
                        const neighbors = this.getNeighbors(current);

                        for (const neighbor of neighbors) {
                            if (closedSet.has(neighbor)) continue;

                            const tentativeGScore = current.gScore + 1;

                            if (!openSet.includes(neighbor)) {
                                openSet.push(neighbor);
                            } else if (tentativeGScore >= neighbor.gScore) {
                                continue;
                            }

                            neighbor.parent = current;
                            neighbor.gScore = tentativeGScore;
                            neighbor.fScore = neighbor.gScore + this.manhattanDistance(neighbor, this.endNode);

                            // 視覺化開放列表中的節點（除非是起點或終點）
                            if (!neighbor.isStart && !neighbor.isEnd) {
                                neighbor.element.classList.add('open');
                            }
                        }

                        // 每一步之間的延遲
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }

                    // 沒有找到路徑
                    document.getElementById('status').textContent = '無法找到路徑！';
                    this.isRunning = false;
                    document.getElementById('findPathBtn').disabled = false;
                }

                clearVisualization() {
                    for (let row = 0; row < this.gridSize; row++) {
                        for (let col = 0; col < this.gridSize; col++) {
                            const node = this.grid[row][col];
                            node.element.classList.remove('open', 'closed', 'path');
                            node.gScore = Infinity;
                            node.fScore = Infinity;
                            node.parent = null;
                            node.isVisited = false;
                        }
                    }
                }

                reset() {
                    if (this.isRunning) return;

                    this.startNode = null;
                    this.endNode = null;
                    this.setupPhase = 'start';

                    for (let row = 0; row < this.gridSize; row++) {
                        for (let col = 0; col < this.gridSize; col++) {
                            const node = this.grid[row][col];
                            node.isStart = false;
                            node.isEnd = false;
                            node.isWall = false;
                            node.gScore = Infinity;
                            node.fScore = Infinity;
                            node.parent = null;
                            node.isVisited = false;
                            node.element.className = 'cell';
                        }
                    }

                    document.getElementById('findPathBtn').disabled = false;
                    this.updateStatus();
                }
            }

            // 初始化應用程式
            document.addEventListener('DOMContentLoaded', () => {
                new AStarVisualizer();
            });
        </script>
    </body>

</html>
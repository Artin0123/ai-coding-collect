<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* 寻路算法可视化工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f9f9f9;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .grid-container {
            display: grid;
            grid-template-columns: repeat(25, 20px);
            grid-template-rows: repeat(25, 20px);
            gap: 0;
        }
        
        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
        }
        
        .start {
            background-color: #2ecc71;
        }
        
        .end {
            background-color: #e74c3c;
        }
        
        .wall {
            background-color: #34495e;
        }
        
        .open {
            background-color: #aed6f1;
        }
        
        .closed {
            background-color: #f5cba7;
        }
        
        .path {
            background-color: #f1c40f;
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .status {
            margin-top: 10px;
            font-size: 16px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>A* Pathfinding Visualizer</h1>
        <div class="grid-container" id="grid"></div>
        <div class="controls">
            <button id="start-btn">开始寻路 (Find Path)</button>
            <button id="reset-btn">重设 (Reset)</button>
        </div>
        <div class="status" id="status">请点击设置起点</div>
    </div>

    <script>
        // 全局变量
        const gridSize = 25;
        let grid = [];
        let startNode = null;
        let endNode = null;
        let isDrawingWalls = false;
        let isPathfinding = false;
        let setupMode = 'start'; // 'start', 'end', 'wall'
        
        // DOM 元素
        const gridContainer = document.getElementById('grid');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const statusText = document.getElementById('status');
        
        // 初始化网格
        function initializeGrid() {
            gridContainer.innerHTML = '';
            grid = [];
            
            for (let row = 0; row < gridSize; row++) {
                grid[row] = [];
                for (let col = 0; col < gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // 添加事件监听器
                    cell.addEventListener('mousedown', handleMouseDown);
                    cell.addEventListener('mouseover', handleMouseOver);
                    cell.addEventListener('mouseup', handleMouseUp);
                    
                    gridContainer.appendChild(cell);
                    
                    // 初始化网格数据
                    grid[row][col] = {
                        element: cell,
                        row: row,
                        col: col,
                        isStart: false,
                        isEnd: false,
                        isWall: false,
                        g: 0, // 从起点到当前节点的实际代价
                        h: 0, // 从当前节点到终点的估计代价（启发式）
                        f: 0, // f = g + h
                        parent: null // 用于重建路径
                    };
                }
            }
        }
        
        // 鼠标事件处理
        function handleMouseDown(e) {
            if (isPathfinding) return;
            
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            
            if (setupMode === 'start') {
                // 设置起点
                if (startNode) {
                    startNode.isStart = false;
                    startNode.element.classList.remove('start');
                }
                
                startNode = grid[row][col];
                startNode.isStart = true;
                startNode.element.classList.add('start');
                
                setupMode = 'end';
                statusText.textContent = '请点击设置终点';
            } else if (setupMode === 'end') {
                // 设置终点
                if (grid[row][col].isStart) return; // 不能在起点上设置终点
                
                if (endNode) {
                    endNode.isEnd = false;
                    endNode.element.classList.remove('end');
                }
                
                endNode = grid[row][col];
                endNode.isEnd = true;
                endNode.element.classList.add('end');
                
                setupMode = 'wall';
                statusText.textContent = '按住鼠标左键并拖动来绘制障碍物';
            } else if (setupMode === 'wall') {
                // 开始绘制墙壁
                if (!grid[row][col].isStart && !grid[row][col].isEnd) {
                    isDrawingWalls = true;
                    toggleWall(row, col);
                }
            }
        }
        
        function handleMouseOver(e) {
            if (isPathfinding || !isDrawingWalls || setupMode !== 'wall') return;
            
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            
            if (!grid[row][col].isStart && !grid[row][col].isEnd) {
                toggleWall(row, col);
            }
        }
        
        function handleMouseUp() {
            isDrawingWalls = false;
        }
        
        // 切换墙壁状态
        function toggleWall(row, col) {
            const node = grid[row][col];
            
            if (node.isWall) {
                node.isWall = false;
                node.element.classList.remove('wall');
            } else {
                node.isWall = true;
                node.element.classList.add('wall');
            }
        }
        
        // A* 寻路算法
        async function findPath() {
            if (!startNode || !endNode) {
                statusText.textContent = '请先设置起点和终点';
                return;
            }
            
            isPathfinding = true;
            startBtn.disabled = true;
            statusText.textContent = '正在寻找路径...';
            
            // 清除之前的可视化
            clearVisualization();
            
            // 重置节点属性
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const node = grid[row][col];
                    node.g = 0;
                    node.h = 0;
                    node.f = 0;
                    node.parent = null;
                }
            }
            
            // 开放列表和封闭列表
            const openSet = [];
            const closedSet = [];
            
            // 将起点加入开放列表
            openSet.push(startNode);
            
            // 主循环
            while (openSet.length > 0) {
                // 找到开放列表中 f 值最小的节点
                let currentIndex = 0;
                for (let i = 0; i < openSet.length; i++) {
                    if (openSet[i].f < openSet[currentIndex].f) {
                        currentIndex = i;
                    }
                }
                
                const current = openSet[currentIndex];
                
                // 如果找到终点
                if (current === endNode) {
                    await reconstructPath();
                    isPathfinding = false;
                    startBtn.disabled = false;
                    statusText.textContent = '路径已找到！';
                    return;
                }
                
                // 从开放列表中移除当前节点
                openSet.splice(currentIndex, 1);
                
                // 将当前节点加入封闭列表
                closedSet.push(current);
                
                // 可视化封闭列表
                if (!current.isStart && !current.isEnd) {
                    current.element.classList.add('closed');
                }
                
                // 获取相邻节点
                const neighbors = getNeighbors(current);
                
                for (const neighbor of neighbors) {
                    // 如果邻居在封闭列表中或是墙壁，则跳过
                    if (closedSet.includes(neighbor) || neighbor.isWall) {
                        continue;
                    }
                    
                    // 计算从起点经过当前节点到邻居的代价
                    const tentativeG = current.g + 1;
                    
                    // 如果邻居不在开放列表中，或者找到了更好的路径
                    if (!openSet.includes(neighbor) || tentativeG < neighbor.g) {
                        neighbor.parent = current;
                        neighbor.g = tentativeG;
                        neighbor.h = manhattanDistance(neighbor, endNode);
                        neighbor.f = neighbor.g + neighbor.h;
                        
                        // 如果邻居不在开放列表中，则加入
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                            
                            // 可视化开放列表
                            if (!neighbor.isStart && !neighbor.isEnd) {
                                neighbor.element.classList.add('open');
                            }
                        }
                    }
                }
                
                // 添加延迟以便可视化
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            // 如果开放列表为空且未找到路径
            isPathfinding = false;
            startBtn.disabled = false;
            statusText.textContent = '无法找到路径！';
        }
        
        // 获取相邻节点
        function getNeighbors(node) {
            const neighbors = [];
            const { row, col } = node;
            
            // 上下左右四个方向
            const directions = [
                { row: -1, col: 0 }, // 上
                { row: 1, col: 0 },  // 下
                { row: 0, col: -1 }, // 左
                { row: 0, col: 1 }   // 右
            ];
            
            for (const dir of directions) {
                const newRow = row + dir.row;
                const newCol = col + dir.col;
                
                // 检查边界
                if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
                    neighbors.push(grid[newRow][newCol]);
                }
            }
            
            return neighbors;
        }
        
        // 曼哈顿距离（启发式函数）
        function manhattanDistance(nodeA, nodeB) {
            return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);
        }
        
        // 重建路径
        async function reconstructPath() {
            let current = endNode;
            
            while (current !== startNode) {
                current = current.parent;
                
                if (current !== startNode) {
                    current.element.classList.remove('open', 'closed');
                    current.element.classList.add('path');
                    
                    // 添加延迟以便可视化
                    await new Promise(resolve => setTimeout(resolve, 20));
                }
            }
        }
        
        // 清除可视化（保留起点、终点和墙壁）
        function clearVisualization() {
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const node = grid[row][col];
                    node.element.classList.remove('open', 'closed', 'path');
                }
            }
        }
        
        // 重置整个网格
        function resetGrid() {
            startNode = null;
            endNode = null;
            isPathfinding = false;
            setupMode = 'start';
            startBtn.disabled = false;
            statusText.textContent = '请点击设置起点';
            initializeGrid();
        }
        
        // 事件监听器
        startBtn.addEventListener('click', findPath);
        resetBtn.addEventListener('click', resetGrid);
        
        // 防止拖动时选中文本
        document.addEventListener('dragstart', e => e.preventDefault());
        
        // 初始化
        initializeGrid();
    </script>
</body>
</html>
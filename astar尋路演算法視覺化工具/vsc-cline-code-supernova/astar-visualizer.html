<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>A* Pathfinding Visualizer</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: Arial, sans-serif;
                background-color: #f5f5f5;
                min-height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }

            h1 {
                text-align: center;
                margin-bottom: 20px;
                color: #333;
            }

            .grid-container {
                display: inline-block;
                border: 2px solid #333;
                background-color: #fff;
            }

            .grid {
                display: grid;
                grid-template-columns: repeat(25, 20px);
                grid-template-rows: repeat(25, 20px);
                gap: 0;
            }

            .cell {
                width: 20px;
                height: 20px;
                border: 1px solid #ccc;
                background-color: #fdfdfd;
            }

            .cell.start {
                background-color: #2ecc71;
            }

            .cell.end {
                background-color: #e74c3c;
            }

            .cell.wall {
                background-color: #34495e;
            }

            .cell.open {
                background-color: #aed6f1;
            }

            .cell.closed {
                background-color: #f5cba7;
            }

            .cell.path {
                background-color: #f1c40f;
            }

            .controls {
                margin-top: 20px;
                display: flex;
                gap: 10px;
                justify-content: center;
            }

            button {
                background-color: #3498db;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                transition: background-color 0.3s;
            }

            button:hover:not(:disabled) {
                background-color: #2980b9;
            }

            button:disabled {
                background-color: #bdc3c7;
                cursor: not-allowed;
            }

            .instructions {
                text-align: center;
                margin-top: 20px;
                color: #666;
                max-width: 600px;
            }
        </style>
    </head>

    <body>
        <h1>A* Pathfinding Visualizer</h1>

        <div class="grid-container">
            <div class="grid" id="grid"></div>
        </div>

        <div class="controls">
            <button id="findPathBtn">開始尋路</button>
            <button id="resetBtn">重設</button>
        </div>

        <div class="instructions">
            <p>操作說明：</p>
            <p>1. 點擊網格設定起點（綠色）</p>
            <p>2. 再次點擊設定終點（紅色）</p>
            <p>3. 按住滑鼠拖曳繪製障礙物（深灰色）</p>
            <p>4. 點擊「開始尋路」觀看演算法運作</p>
        </div>

        <script>
            // Grid configuration
            const ROWS = 25;
            const COLS = 25;
            const CELL_SIZE = 20;

            // Node types
            const EMPTY = 0;
            const WALL = 1;
            const START = 2;
            const END = 3;
            const OPEN = 4;
            const CLOSED = 5;
            const PATH = 6;

            // Colors corresponding to node types
            const colors = {
                [EMPTY]: '#fdfdfd',
                [WALL]: '#34495e',
                [START]: '#2ecc71',
                [END]: '#e74c3c',
                [OPEN]: '#aed6f1',
                [CLOSED]: '#f5cba7',
                [PATH]: '#f1c40f'
            };

            // Grid state
            let grid = [];
            let startNode = null;
            let endNode = null;
            let isSettingStart = true;
            let isMouseDown = false;
            let isFindingPath = false;

            // DOM elements
            const gridElement = document.getElementById('grid');
            const findPathBtn = document.getElementById('findPathBtn');
            const resetBtn = document.getElementById('resetBtn');

            // Initialize grid
            function initGrid() {
                grid = [];
                gridElement.innerHTML = '';

                for (let row = 0; row < ROWS; row++) {
                    const currentRow = [];
                    for (let col = 0; col < COLS; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;

                        // Add event listeners
                        cell.addEventListener('click', handleCellClick);
                        cell.addEventListener('mousedown', handleMouseDown);
                        cell.addEventListener('mouseenter', handleMouseEnter);
                        cell.addEventListener('mouseup', handleMouseUp);

                        gridElement.appendChild(cell);
                        currentRow.push({
                            row,
                            col,
                            type: EMPTY,
                            g: 0,
                            h: 0,
                            f: 0,
                            parent: null,
                            element: cell
                        });
                    }
                    grid.push(currentRow);
                }
            }

            // Handle cell click
            function handleCellClick(e) {
                if (isFindingPath) return;

                const cell = e.target;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const node = grid[row][col];

                if (isSettingStart || !startNode) {
                    // Set start node
                    if (startNode) {
                        startNode.type = EMPTY;
                        startNode.element.className = 'cell';
                        startNode.element.style.backgroundColor = colors[EMPTY];
                    }

                    startNode = node;
                    node.type = START;
                    node.element.className = 'cell start';
                    node.element.style.backgroundColor = colors[START];
                    isSettingStart = false;
                } else if (!endNode) {
                    // Set end node
                    endNode = node;
                    node.type = END;
                    node.element.className = 'cell end';
                    node.element.style.backgroundColor = colors[END];
                }
            }

            // Handle mouse down
            function handleMouseDown(e) {
                if (isFindingPath) return;
                isMouseDown = true;
                handleMouseEnter(e);
            }

            // Handle mouse enter
            function handleMouseEnter(e) {
                if (!isMouseDown || isFindingPath) return;

                const cell = e.target;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const node = grid[row][col];

                // Don't allow drawing walls on start or end nodes
                if (node.type === START || node.type === END) return;

                if (node.type !== WALL) {
                    node.type = WALL;
                    node.element.className = 'cell wall';
                    node.element.style.backgroundColor = colors[WALL];
                }
            }

            // Handle mouse up
            function handleMouseUp() {
                isMouseDown = false;
            }

            // Manhattan distance heuristic
            function heuristic(a, b) {
                return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);
            }

            // Get neighbors of a node
            function getNeighbors(node) {
                const neighbors = [];
                const { row, col } = node;

                // Check all 4 directions
                const directions = [
                    { row: row - 1, col },
                    { row: row + 1, col },
                    { row, col: col - 1 },
                    { row, col: col + 1 }
                ];

                for (const dir of directions) {
                    const newRow = dir.row;
                    const newCol = dir.col;

                    // Check bounds
                    if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                        const neighbor = grid[newRow][newCol];
                        // Don't include walls
                        if (neighbor.type !== WALL) {
                            neighbors.push(neighbor);
                        }
                    }
                }

                return neighbors;
            }

            // Reconstruct path from end node
            function reconstructPath(endNode) {
                const path = [];
                let current = endNode;

                while (current !== null) {
                    path.unshift(current);
                    current = current.parent;
                }

                return path;
            }

            // A* algorithm with visualization
            async function aStar() {
                if (!startNode || !endNode) {
                    alert('請先設定起點和終點！');
                    return;
                }

                if (isFindingPath) return;
                isFindingPath = true;

                // Disable find path button
                findPathBtn.disabled = true;

                // Reset all nodes except start, end, and walls
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const node = grid[row][col];
                        if (node.type !== START && node.type !== END && node.type !== WALL) {
                            node.type = EMPTY;
                            node.element.style.backgroundColor = colors[EMPTY];
                            node.element.className = 'cell';
                            node.g = 0;
                            node.h = 0;
                            node.f = 0;
                            node.parent = null;
                        }
                    }
                }

                const openSet = [startNode];
                const closedSet = new Set();

                startNode.g = 0;
                startNode.h = heuristic(startNode, endNode);
                startNode.f = startNode.g + startNode.h;

                while (openSet.length > 0) {
                    // Find node with lowest f score
                    openSet.sort((a, b) => a.f - b.f);
                    const current = openSet.shift();

                    // Skip if already in closed set
                    if (closedSet.has(current)) continue;

                    // Mark as closed
                    closedSet.add(current);
                    if (current !== startNode && current !== endNode) {
                        current.type = CLOSED;
                        current.element.style.backgroundColor = colors[CLOSED];
                        current.element.className = 'cell closed';
                    }

                    // Check if we reached the end
                    if (current === endNode) {
                        const path = reconstructPath(endNode);

                        // Visualize the path
                        for (let i = 1; i < path.length - 1; i++) {
                            const node = path[i];
                            node.type = PATH;
                            node.element.style.backgroundColor = colors[PATH];
                            node.element.className = 'cell path';
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }

                        isFindingPath = false;
                        findPathBtn.disabled = false;
                        return;
                    }

                    // Check neighbors
                    const neighbors = getNeighbors(current);

                    for (const neighbor of neighbors) {
                        if (closedSet.has(neighbor)) continue;

                        const tentativeG = current.g + 1;

                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);

                            if (neighbor !== endNode) {
                                neighbor.type = OPEN;
                                neighbor.element.style.backgroundColor = colors[OPEN];
                                neighbor.element.className = 'cell open';
                            }
                        } else if (tentativeG >= neighbor.g) {
                            continue;
                        }

                        // Update neighbor
                        neighbor.parent = current;
                        neighbor.g = tentativeG;
                        neighbor.h = heuristic(neighbor, endNode);
                        neighbor.f = neighbor.g + neighbor.h;
                    }

                    // Small delay for visualization
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                // No path found
                alert('找不到路徑！終點可能被障礙物完全包圍。');
                isFindingPath = false;
                findPathBtn.disabled = false;
            }

            // Reset grid
            function resetGrid() {
                isFindingPath = false;
                startNode = null;
                endNode = null;
                isSettingStart = true;
                findPathBtn.disabled = false;
                initGrid();
            }

            // Event listeners for buttons
            findPathBtn.addEventListener('click', aStar);
            resetBtn.addEventListener('click', resetGrid);

            // Initialize the grid on page load
            initGrid();
        </script>
    </body>

</html>
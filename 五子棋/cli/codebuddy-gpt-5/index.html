<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>五子棋</title>
<style>
html,body{height:100%;margin:0}
body{display:flex;align-items:center;justify-content:center;background:#f5f5f5;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
#app{background:#fff;border:1px solid #ddd;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.08);padding:16px}
.header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:8px}
.btn{cursor:pointer;border:1px solid #ccc;background:#fff;border-radius:8px;padding:8px 12px}
.status{font-weight:600}
.canvas-wrap{position:relative}
canvas{display:block;touch-action:manipulation}
</style>
</head>
<body>
<div id="app">
  <div class="header">
    <div class="status" id="status"></div>
    <div>
      <button class="btn" id="restart">重新開始</button>
    </div>
  </div>
  <div class="canvas-wrap">
    <canvas id="board"></canvas>
  </div>
</div>
<script>
const N=15
const pad=24
let cell=36
let size=pad*2+cell*(N-1)
const canvas=document.getElementById('board')
const ctx=canvas.getContext('2d')
const statusEl=document.getElementById('status')
const restartBtn=document.getElementById('restart')
let board
let over=false
let human=1
let ai=2
let turn=human
function initBoard(){
  board=Array.from({length:N},()=>Array(N).fill(0))
  over=false
  turn=human
  draw()
  setStatus()
}
function resize(){
  const maxW=Math.min(720,Math.min(window.innerWidth-40,window.innerHeight-140))
  cell=Math.max(26,Math.floor((maxW-2*pad)/(N-1)))
  size=pad*2+cell*(N-1)
  canvas.width=size
  canvas.height=size
  draw()
}
function draw(){
  ctx.clearRect(0,0,size,size)
  ctx.fillStyle='#f0d9b5'
  ctx.fillRect(0,0,size,size)
  ctx.strokeStyle='#444'
  ctx.lineWidth=1
  for(let i=0;i<N;i++){
    const o=pad
    const x=o+i*cell
    const y=o+i*cell
    ctx.beginPath();ctx.moveTo(o,i*cell+o);ctx.lineTo(o+(N-1)*cell,i*cell+o);ctx.stroke()
    ctx.beginPath();ctx.moveTo(i*cell+o,o);ctx.lineTo(i*cell+o,o+(N-1)*cell);ctx.stroke()
  }
  const dots=[3,7,11]
  ctx.fillStyle='#333'
  dots.forEach(i=>{dots.forEach(j=>{const x=pad+i*cell;const y=pad+j*cell;ctx.beginPath();ctx.arc(x,y,3,0,Math.PI*2);ctx.fill()})})
  for(let y=0;y<N;y++)for(let x=0;x<N;x++)if(board[y][x])drawStone(x,y,board[y][x])
}
function drawStone(ix,iy,who){
  const x=pad+ix*cell
  const y=pad+iy*cell
  const r=Math.floor(cell*0.45)
  const g=ctx.createRadialGradient(x-2,y-2,2,x,y,r)
  if(who===1){g.addColorStop(0,'#222');g.addColorStop(1,'#000')}else{g.addColorStop(0,'#fff');g.addColorStop(1,'#ccc')}
  ctx.fillStyle=g
  ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill()
}
function setStatus(text){
  if(text){statusEl.textContent=text;return}
  if(over){return}
  statusEl.textContent=turn===human?'你的回合':'電腦思考中...'
}
function toCell(px,py){
  const x=Math.round((px-pad)/cell)
  const y=Math.round((py-pad)/cell)
  if(x<0||y<0||x>=N||y>=N)return null
  const gx=pad+x*cell
  const gy=pad+y*cell
  const dx=Math.abs(px-gx)
  const dy=Math.abs(py-gy)
  if(Math.max(dx,dy)>cell*0.45)return null
  return {x,y}
}
function place(x,y,who){
  if(board[y][x]||over)return false
  board[y][x]=who
  drawStone(x,y,who)
  const w=checkWin(x,y,who)
  if(w){over=true;setStatus(who===human?'你贏了':'電腦獲勝');return true}
  if(isFull()){over=true;setStatus('平手');return true}
  return true
}
function isFull(){
  for(let y=0;y<N;y++)for(let x=0;x<N;x++)if(board[y][x]===0)return false
  return true
}
function checkWin(x,y,who){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]]
  for(const [dx,dy] of dirs){
    let c=1
    let i=1
    while(inb(x+dx*i,y+dy*i)&&board[y+dy*i][x+dx*i]===who){c++;i++}
    i=1
    while(inb(x-dx*i,y-dy*i)&&board[y-dy*i][x-dx*i]===who){c++;i++}
    if(c>=5)return true
  }
  return false
}
function inb(x,y){return x>=0&&y>=0&&x<N&&y<N}
function aiMove(){
  const m=findBestMove()
  if(!m){return}
  place(m.x,m.y,ai)
  if(!over){turn=human;setStatus()}
}
function emptyNeighbors(){
  const s=new Set()
  for(let y=0;y<N;y++)for(let x=0;x<N;x++)if(board[y][x]){
    for(let dy=-2;dy<=2;dy++)for(let dx=-2;dx<=2;dx++){
      const nx=x+dx,ny=y+dy
      if(inb(nx,ny)&&board[ny][nx]===0)s.add(ny*100+nx)
    }
  }
  if(s.size===0){const c=Math.floor(N/2);s.add(c*100+c)}
  return Array.from(s).map(v=>({x:v%100,y:Math.floor(v/100)}))
}
function findBestMove(){
  let best=null
  let bestScore=-1e18
  const moves=emptyNeighbors()
  for(const {x,y} of moves){
    board[y][x]=ai
    if(checkWin(x,y,ai)){board[y][x]=0;return {x,y}}
    board[y][x]=0
  }
  for(const {x,y} of moves){
    board[y][x]=human
    if(checkWin(x,y,human)){board[y][x]=0;return {x,y}}
    board[y][x]=0
  }
  for(const {x,y} of moves){
    const s=evaluateAt(x,y,ai)+evaluateAt(x,y,human)*0.9+centerBias(x,y)
    if(s>bestScore){bestScore=s;best={x,y}}
  }
  return best
}
function centerBias(x,y){
  const c=(N-1)/2
  const dx=Math.abs(x-c)
  const dy=Math.abs(y-c)
  return - (dx+dy)
}
function evaluateAt(x,y,who){
  if(board[y][x]!==0)return -1e9
  let score=0
  const dirs=[[1,0],[0,1],[1,1],[1,-1]]
  for(const [dx,dy] of dirs){
    const a=lineInfo(x,y,dx,dy,who)
    score+=patternScore(a.count,a.open)
  }
  return score
}
function lineInfo(x,y,dx,dy,who){
  let cnt1=0,open1=0
  let i=1
  while(inb(x+dx*i,y+dy*i)&&board[y+dy*i][x+dx*i]===who){cnt1++;i++}
  if(inb(x+dx*i,y+dy*i)&&board[y+dy*i][x+dx*i]===0)open1=1
  let cnt2=0,open2=0
  i=1
  while(inb(x-dx*i,y-dy*i)&&board[y-dy*i][x-dx*i]===who){cnt2++;i++}
  if(inb(x-dx*i,y-dy*i)&&board[y-dy*i][x-dx*i]===0)open2=1
  return {count:cnt1+1+cnt2,open:open1+open2}
}
function patternScore(count,open){
  if(count>=5)return 1e8
  if(count===4&&open===2)return 1e6
  if(count===4&&open===1)return 2e4
  if(count===3&&open===2)return 6e3
  if(count===3&&open===1)return 400
  if(count===2&&open===2)return 200
  if(count===2&&open===1)return 40
  if(count===1&&open===2)return 10
  return 1
}
canvas.addEventListener('click',e=>{
  if(over||turn!==human)return
  const rect=canvas.getBoundingClientRect()
  const p=toCell(e.clientX-rect.left,e.clientY-rect.top)
  if(!p)return
  if(place(p.x,p.y,human)){
    if(!over){turn=ai;setStatus();setTimeout(aiMove,50)}
  }
})
restartBtn.addEventListener('click',()=>{initBoard();setStatus('新的對局開始，黑子先手')})
window.addEventListener('resize',resize)
initBoard()
resize()
setStatus('黑子先手：你先下')
</script>
</body>
</html>